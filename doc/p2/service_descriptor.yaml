---
# Name of the Service deployed in the World
name: hello

# The Deployable artifact which in this hypothetical service descriptor is a Docker image.
deployable:
  type: docker-image
  registry: docker.io
  name: datawire/hello

# Controls the mechanism for how an update is performed.
update:
  # The update strategy (default: rolling, available: blue-green, append-only, rolling)
  strategy: rolling

  # Additional parameters that can be passed to configure how the update is performed, for example, the number of
  # pods rolled in each step.
  parameters: { }

# Network configuration that the developer is allowed to define.
network:

  # "frontends" are discoverable entry points into the system. In a vanilla Kubernetes setup this means mapping a
  # "frontend" to one or more Service manifests.
  #
  # "frontends" can be empty in which case we will create "headless" services in vanilla Kubernetes. That might be
  # highly desirable for Envoy-enabled services.
  #
  # *NOTE*: Frontends more than anything need a lot of definition because they are the access point to a service and
  #         that has implications for updates in the system. For example, blue-green deployments in Kubernetes work by
  #         manipulating the labels and selectors associated with Deployments and Services respectively.
  #
  frontends:
      # how the underlying fabric exposes a service in a vanilla kubernetes the values are mapped as:
      #
      #   private              -> ServiceType.ClusterIP
      #   public               -> ServiceType.NodePort
      #   public:load-balanced -> ServiceType.LoadBalancer
    - type: public

      # The allowed transport protocol (default: tcp, allowed: tcp, udp)
      protocol: tcp

      # The port to be opened.
      port: 80

      # Must reference one of the backend ports defined below
      target: rest-api

  # "backends" are the exposed ports on the container, for example, the hypothetical "Hello" service exposes two ports,
  # one port is for the REST API while another port hosts an administrative API only the author cares about.
  backends:
    - name: rest-api
      protocol: tcp # The allowed transport protocol (default: tcp, allowed: tcp, udp)
      port: 5001

    - name: admin-api
      port: 5002

# Requirements are hard dependencies that must be satisfied by the deployment system before the deployment system
# attempts to start a container. Consider a system that needs TWO PostgreSQL 9.6 *database servers*. When Deployd
# processes the descriptor the following things occur:
#
# requirements.each {
#   if (requirement.type in World.ModuleRepository) {
#     if exists(service.name, requirement.name) and no_diff(requirement.params, existing.params) {
#       val exportedVariables = requirement.exports // these are injected into the kubernetes container (e.g. URL, port, username, password).
#       satisfied()
#     } else {
#       createOrUpdateDependency()
#     }
#   }
#   else {
#     abort()
#   }
# }
#
requirements:
  - name: users
    type: postgresql-v96
    params:
      iops: 100

  - name: votes
    type: postgresql-v96
    params:
      iops: 50

